







Основы веб разработки

Лабораторная работа №2
Аутентификации и авторизации с использованием JWT


Цель работы
Освоить принципы аутентификации и авторизации с использованием JWT (JSON Web Token).
Критерии выполнения
1. Пользователь должен иметь возможность зарегистрироваться и войти в систему используя API.
2. Авторизованные пользователи получают JWT-токен для работы с API.
3. Доступ к защищенным маршрутам должен требовать аутентификации.
4.Хранение паролей должно быть безопасным (использование хеширования).
5. Реализован middleware для проверки авторизации
6. Должны быть выполнено дополнительное задание в соответствии с вариантом. 
7. Работа с репозиторием:
1. Работа над лабораторной должна вестись в отдельной ветке ответвлений от основной (master/main). 
2. В рамках лабораторной работы необходимо сделать минимум 2 коммита:
● Коммит после выполнения основного задания
● Коммит после выполнения дополнительного задания по варианту
3. Для коммитов использовать следующий шаблон названий (типы коммитов можно посмотреть в Приложении 1 к лабораторной работе):
{Тип коммита}: {Номер задачи} <Описание с ответом на вопрос “Что сделано?”>
Пример: feat: LAB2 Добавлено Readme с описанием шагов для запуска приложения
4. Должен быть оформлен Merge Request ветки лабораторной работы в главную ветку. Должно быть указано описание что было сделано, какие здания реализовывались по варианту. Мерж ревест можно смержить сразу, главное без сквоша коммитов и удаления ветки.



Основные шаги выполнения
Установка зависимостей
Перед началом работы установите необходимые пакеты для работы с аутентификацией и авторизацией.
● bcryptjs — для хеширования паролей
● jsonwebtoken — для генерации JWT-токенов
● passport — для аутентификации пользователей
● passport-jwt — для обработки JWT-токенов в passport

Добавление переменных окружения
Необходимо добавить дополнительные переменные окружения которые будут использоваться для настройки авторизации и аутентификации:
● JWT_SECRET=your_jwt_secret

Доработка модели “Пользователь”
1.Создайте в модели пользователя поле password.
2. Настройте хэширование пароля при добавлении в базу.


Настройка Passport.js для аутентификации по JWT
1. Создайте файл config/passport.js
2. Настройте стратегию JWT, которая:
● Получает токен из заголовка запроса.
● Декодирует его с помощью секретного ключа.
● Извлекает из токена идентификатор пользователя и проверяет, существует ли он в базе данных.
● В случае успешной проверки передает пользователя в обработчик запроса.


Реализация маршрута регистрации
1. Создайте новый роутер в файле routes/auth.js
2. Создайте эндпоинт POST /register, который позволит пользователю зарегистрироваться в системе.
● Эндпоинт должен принимать данные, такие как email, имя пользователя и пароль.
● Проверять существует ли уже пользователь с таким email в базе данных.
● Если email уникален, создавать нового пользователя.
● После успешного создания пользователя сервер должен возвращать сообщение об успешной регистрации.


Реализация маршрута авторизации
Создайте эндпоинт POST /login в роутер /auth, который позволит пользователю входить в систему.
1. Эндпоинт должен принимать данные, такие как email и пароль.
2. По email искать пользователь в базе данных.
3. Если пользователь найден, выполнять проверку пароля (сравнение с хешем)
4. В случае успешной аутентификации сервер генерирует JWT-токен и отправляет его клиенту.
5. Токен содержит информацию о пользователе и срок действия.
Этот токен будет использоваться клиентом для доступа к защищенным маршрутам API.


 Использование Passport.js для защиты маршрутов
Чтобы запретить доступ к определенным маршрутам для неавторизованных пользователей, необходимо добавить middleware для аутентификации или добавить проверку аутентификации в отдельных роутерах.
1. Создайте отдельный роутер routes/public.
2. Перенесите туда все публичные маршруты для которых не нужна аутентификация (на данный момент только GET /events)
3. Для защищенных маршрутов (в роутере routes/index) примените проверку с использованием passport


Важно! Чтобы  passport заработал – не забудьте добавить его инициализацию в при старте сервера

Задания по вариантам
1. Реализовать выход из системы
Описание:
При выходе из системы JWT-токен пользователя должен становиться недействительным, чтобы его нельзя было использовать повторно.
Шаги возможной реализации:
1. Добавить API POST /auth/logout, который будет вызываться клиентом при выходе.
2. Создать механизм хранения "черного списка" токенов в базе данных.
3. При каждом запросе проверять, есть ли токен в этом списке, и отклонять запрос, если он уже был использован. (использовать middleware).


2.  Добавить обновление JWT-токена (Refresh Token)
Описание:
Для повышения безопасности пользователь должен получать новый access token по refresh token, не вводя повторно логин и пароль.
Шаги возможной реализации:
1. Добавить в базу данных таблицу refreshTokens с user_id, token, expires_at.
2. При входе выдавать два токена:
○ Access Token (действителен, например, 15 минут).
○ Refresh Token (действителен несколько дней/недель).
3. Создать API POST /auth/refresh, который:
○ Проверяет наличие refresh token в БД.
○ Генерирует новый access token.

3. Добавить роли пользователей (admin, user)
Описание:
Разные пользователи должны иметь разные уровни доступа: например, администратор может управлять всеми пользователями, а обычный пользователь — только своими данными.
Шаги реализации:
1. В модель User добавить поле role (например, ENUM('user', 'admin')).
2. При регистрации по умолчанию присваивать роль user.
3. В middleware аутентификации добавить проверку req.user.role.
4. Разграничить доступ к API:
○ /users — доступен только admin.
○ /events — доступен user, но редактирование возможно только своих событий.
5. Опционально: создать API PATCH /users/:id/role, доступный только администраторам, для смены ролей пользователей.


4. Добавить блокировку аккаунта после нескольких неудачных попыток входа
Описание:
Для защиты от перебора паролей (brute-force) необходимо временно блокировать учетную запись после нескольких неудачных попыток входа.
Шаги возможной реализации:
1. В таблицу users добавить поля failed_attempts, isLocked и lockUntil.
2. При неудачной попытке входа увеличивать failed_attempts.
3. Если failedAttempts > 5 — установить isLocked = true и lockUntil = текущее время + время блокировки, и вернуть ошибку.
4. Создать механизм автоматической разблокировки после истечения таймера (при новом логине проверять, прошло ли время из lockUntil).

5. Реализовать email-уведомления при входе с нового устройства или из нового местоположения
Описание:
Если пользователь входит в аккаунт с нового IP-адреса или устройства, ему должно приходить уведомление xпо email для повышения безопасности.
Шаги реализации:
1. При успешном входе проверять IP-адрес и User-Agent (браузер, устройство).
2. Хранить в базе последние N IP-адресов и User-Agent каждого пользователя.
3. Если новый IP-адрес или устройство не совпадает с сохраненными, отправлять email с предупреждением.

Варианты

ВариантФункциональное112233445561728394105111122133144155161172183194205211222233244255261272



Контрольные вопросы
1. В чем разница между аутентификацией и авторизацией?
2. Как работает JWT-токен и зачем он используется?
3. Почему пароли пользователей должны храниться в хешированном виде?
4. Как passport.js помогает в аутентификации пользователей?
5. Как реализуется защита маршрутов с помощью passport.authenticate("jwt")?
6. Какие данные обычно включаются в payload JWT-токена?
7. Как проверить JWT-токен на сервере?
8. В чем разница между access token и refresh token?
9. Как можно обезопасить хранение JWT-токена на клиенте?
10. Как настроить Passport.js для работы с JWT?
11. Как протестировать защищенные маршруты API с использованием Postman или cURL?
12. Какие способы ограничения доступа к API существуют, кроме аутентификации по JWT?


Приложение 1
Соглашение о коммитах

Типы в коммитах
● Изменения, относящиеся к функционалу
○ feat – Коммиты, которые добавляют или удаляют новый функционал
○ fix – Коммиты, исправляющие ошибки
● refactor – Коммиты, которые переписывают/реструктурируют ваш код, однако не изменяют поведение.
○ perf коммиты это специальные refactor-коммиты, которые улучшают производительность.
● style – Коммиты, которые не влияют на смысл (пробелы, форматирование, пропущенные точки с запятой и т. д.)
● test – Коммиты, добавляющие отсутствующие тесты или исправляющие существующие тесты
● docs – Коммиты, которые влияют только на документацию
● chore – Различные коммиты, например, изменение.gitignore

Типы в ветках
● feature - добавление нового функционала
● fix - исправление ошибок
● refactor - рефакторинг кода без исправления ошибок или добавления новых функций
● perf - изменения направленные на улучшение производительности
● style - правки по код-стайлу
● test - добавление и изменение тестов
● doc - обновление документации

Документация по git
https://git-scm.com/book/ru/v2
