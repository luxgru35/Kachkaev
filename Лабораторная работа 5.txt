







Основы веб разработки

Лабораторная работа №5
Продвинутый фронтенд на React


Цель работы
Перевести приложение на использование Redux Toolkit для управления состоянием, добавить дополнительные страницы (профиль, создание/редактирование мероприятий) и завершить реализацию клиентской части веб-приложения.
Критерии выполнения
1. В дополнении к существующим страницам пользователю должны быть доступны следующие страницы: 
● Профиль пользователя
○ Страница должна включать информацию о пользователе (имя и email)
○ Страница доступна только авторизованному пользователю
○ На странице должны отображаться мероприятия созданные пользователем аналогичными карточками, как и на странице мероприятий

Пример расположения элементов на странице
● Страница создания/редактирования мероприятия
○ Должна включать форму для создания/редактирования мероприятия.
○ Страница доступна только авторизованному пользователю
○ Можно реализовать в виде модального окна
○ Должна быть настроена валидация данных в форме (длинна текста, невозможность выбрать дату мероприятия раньше текущей и т.д.). 
○ Должны быть учтены все дополнительные поля из доп. заданий по вариантам, если такие имеются (например загрузка картинок, категория). Должны быть использованы соответствующие инпуты (например для категорий - селект с выпадающим списком)
○ Компонент формы должен быть переиспользуемым и применяться как для функционала создания, так и для редактирования мероприятия. При редактировании поля должны быть уже заполненные редактируемыми данными.
○ Форма должна быть реализована с использованием одной из библиотек: react-hook-form или formik
Страницы должны быть удобным и понятным с точки зрения пользователя, допускается использование любых других элементов для создания дизайна страницы.
Страница должна корректно отображаться на разрешениях больше 320px (Должен быть минимальный адаптив). 
2. Использование Redux Toolkit
● Подключен и настроен Redux Toolkit
● Создан store, разбит на слайсы ( например authSlice, eventsSlice, uiSlice и т.д.)
● Состояние авторизации, пользователь, список мероприятий и фильтры перенесены в Redux
●  Использование useSelector и useDispatch вместо useState/useContext (если использовались)
●  Использован createAsyncThunk для асинхронных запросов к API
3. Прочие улучшения
● Все данные получаемые с бекенда помещаются в Redux
● Отображение лоадеров при запросах (Пока выполняется запрос должен отображаться специальный компонент (Например который отображает текст “Загрузка”)
● Единый компонент для отображения ошибок (<ErrorNotification/>)
● Компоненты по возможности переиспользуются (например, EventCard, AuthForm, EventForm)

4. При случае ошибки при выполнении запроса к серверу необходимо на странице отобразить корректное сообщение об этом (Код ошибки + краткий текст ошибки). Использовать alert, prompt, confirm запрещено, ошибку необходимо отображать на самой странице странице.
5. Должны быть выполнено дополнительное задание в соответствии с вариантом. 
6. Работа с репозиторием:
1. Работа над лабораторной должна вестись в отдельной ветке ответвлений от основной (master/main). 
2. В рамках лабораторной работы необходимо сделать минимум 3 коммита:
● Коммит после инициализации фронтенд проекта
● Коммит после выполнения основного задания
● Коммит после выполнения дополнительного задания по варианту
3. Для коммитов использовать следующий шаблон названий (типы коммитов можно посмотреть в Приложении 1 к лабораторной работе):
{Тип коммита}: {Номер задачи} <Описание с ответом на вопрос “Что сделано?”>
Пример: feat: LAB2 Добавлено Readme с описанием шагов для запуска приложения
4. Должен быть оформлен Merge Request ветки лабораторной работы в главную ветку. Должно быть указано описание что было сделано, какие здания реализовывались по варианту. Мерж ревест можно смержить сразу, главное без сквоша коммитов и удаления ветки.



Краткая теория по Redux Toolkit
Вводная часть
Redux — это библиотека для управления состоянием в JavaScript-приложениях.
Она помогает централизованно хранить и изменять данные, которыми пользуются разные компоненты.

Когда нужен Redux?
● Много компонентов, и они обмениваются данными
● Нужно предсказуемое поведение (всё управление данными чётко описано)
● Важно хранить и контролировать состояние (например, пользователь авторизован, список товаров, фильтры и т.п.)

Как работает Redux?
1. Компонент отправляет action — объект, описывающий, что нужно изменить.
2. Reducer получает текущий state и action, и возвращает новый state.
3. Redux обновляет store (глобальное хранилище).
4. Компоненты, подписанные на это состояние, автоматически получают обновления.

Что такое Redux Toolkit?
Redux Toolkit (RTK) — это официальная надстройка над Redux, которая:
● Упрощает его использование
● Убирает "шаблонный" (boilerplate) код
● Дает готовые инструменты для работы с асинхронностью, slices, store и т.п.

Термины
State — это объект, который содержит все данные приложения, нужные для работы интерфейса. В Redux он глобальный и хранится централизованно в одном месте — в store.

Store — это объект, который хранит state, позволяет его изменять, подключён ко всем компонентам.
Создается с помощью configureStore() и содержит все редьюсеры и middleware.

Action — это объект, который описывает, что должно произойти в приложении. У каждого action'а есть минимум поле type. Также в экшене может передаваться полезная нагрузка – обычно помещается в поле payload.

Reducer — это функция, которая получает текущее состояние и action, а затем возвращает новое состояние.

Slice — это логически выделенная часть состояния и редьюсеров, объединенная в один модуль. Например, authSlice, eventsSlice, uiSlice.
createSlice позволяет сразу:
● Создать слайс (часть общего состояния)
● Написать редьюсеры — функции, изменяющие состояние
● Сгенерировать actions — команды для изменения состояния


Dispatch — это функция, которую вызываемая, чтобы отправить action и инициировать изменение состояния.

useSelector — это хук, который позволяет компоненту доставать нужные данные из Redux-состояния.
createAsync Thunk – позволяет выполнять асинхронные запросы к серверу и автоматически генерирует три стадии:
● pending — запрос начался
● fulfilled — запрос завершён успешно
● rejected — ошибка при запросе







Основные шаги выполнения
Подключение и настройка Redux Toolkit
1. Установить зависимости:

2. Создать store в src/app/store.ts и подключить его (Редьюсеры показаны для примера):
3. Обернуть приложение в Provider в main.tsx:
4. Создать обёртки-хуки (Чтобы избежать дублирования типов в useDispatch и useSelector):
5. Теперь можно использовать useAppDispatch() и useAppSelector() в компонентах вместо обычных хуков.



Создание и настройка слайсов Redux
1. Реализовать слайсы для аутентификация, регистрации и получения списка событий
2. Пример слайса для аутентификации


      Рекомендации по выполнению данного шага:
1. Важно не забыть добавить в состояния хранимые слайсом флаги isLoading (указывает на то, выполняется ли сейчас загрузка данных, можно использовать для отображения лодера) и isError ( указывает на то, произошла ли при запросе данных ошибка, можно использовать для отображения сообщения об ошибке).
2. Для выполнения запросов к серверу необходимо использовать createAsyncThunk, это дает возможность обрабатывать различные состояния запроса ( pending – в процессе, fulfilled – выполнен успешно, rejected – выполнен с ошибкой)
3. Не забывайте экспортировать экшены и редьюссер для дальнейшего использования



Подключение слайсов для использования в компонентах
1. Для выполнения запросов к серверу из компонентов с использованием createAsyncThunk – thunk, необходимо в первую очередь получить функцию dispatch позволяющую запускать thunk’и.
2. Там где это необходимо – вызвать нужный thunk использовав dispatch
3. Для извлечения данных из стора необходимо использовать хук useAppSelector. При изменении данных в сторе, будет происходить изменение данных в компонентах.


Создание защищенных роутов
1.  Создать компонент ProtectedRoute
2. Обновить маршруты в App.tsx или routes.tsx



Создание страницы профиля
1. Для получения данных для профиля необходимо создать отдельный эндпоинт для получения данных пользователя на бекенде. Эндпоинт не должен содержать пароль пользователя.
2. Для отображения мероприятий созданных пользователем необходимо создать отдельный эндпоинт на бекенде возвращающий список мероприятий для пользователя по его id.


Создание страницы создания/редактирования событий
Рекомендации по выполнению данного шага:
1. На уровне страницы можно проверять есть ли в url id события, если есть то считаем что это редактирование. Например можно сделать следующим образом:

2. В EventForm по наличию значения event можно разделить логику на создание и редактирование.
3. Для создания формы необходимо использовать одну из библиотек: react-hook-form или formik



Задания по вариантам
1. Добавить дополнительные поля для пользователя:
● Поля должны заполняться при регистрации и выводиться их в профиле пользователя
● Список полей:  ФИО отдельными полями, пол, дата рождения
● Добавить возможность редактировать поля в профиле пользователя
● Поля должны быть обязательными и иметь валидацию при заполнении
● Для выполнения задачи необходимо доработать эндпоинт в бекенд части приложения
2. Добавить возможность регистрироваться как участник на мероприятия:
● У мероприятий созданных другими пользователями должна появиться дополнительная кнопка на карточке мероприятия (например “Участвовать”).
● В мероприятиях созданных пользователем кнопка должна отсутствовать
● Добавить в карточки мероприятий количество пользователей, которые нажали кнопку “Участвовать”
● При нажатии на количество пользователей, должно открываться модальное окно со списком пользователей, которые нажали кнопку “Участвовать”
● Для выполнения задачи необходимо доработать эндпоинт в бекенд части приложения
Варианты

ВариантЗадание112231425162718291102111122131142151162171182191202211222231242251262271



Контрольные вопросы
Общие вопросы по Redux и Redux Toolkit
1. Что такое Redux и для чего он используется?
2. Что такое store в Redux?
3. Что такое state в контексте Redux?
4. Что такое reducer и как он работает?
5. Что такое slice в Redux Toolkit?
6. Что такое action и как он создается?
7. Как использовать useSelector и useDispatch?
8. Что делает createSlice и какие преимущества он даёт?
9. Что такое createAsyncThunk и как с его помощью выполнять асинхронные запросы?
10. Как обрабатывать состояния загрузки, успеха и ошибки в createAsyncThunk?
11. Почему Redux Toolkit считается предпочтительным способом работы с Redux?

 Авторизация и защищённые маршруты
14. Что такое защищённые маршруты (Protected Routes)?
Как реализовать проверку авторизации пользователя при переходе на защищённую страницу?
15. Как можно организовать редирект неавторизованного пользователя на страницу логина?
16. Как использовать состояние авторизации из Redux для контроля доступа?


Приложение 1
Соглашение о коммитах

Типы в коммитах
● Изменения, относящиеся к функционалу
○ feat – Коммиты, которые добавляют или удаляют новый функционал
○ fix – Коммиты, исправляющие ошибки
● refactor – Коммиты, которые переписывают/реструктурируют ваш код, однако не изменяют поведение.
○ perf коммиты это специальные refactor-коммиты, которые улучшают производительность.
● style – Коммиты, которые не влияют на смысл (пробелы, форматирование, пропущенные точки с запятой и т. д.)
● test – Коммиты, добавляющие отсутствующие тесты или исправляющие существующие тесты
● docs – Коммиты, которые влияют только на документацию
● chore – Различные коммиты, например, изменение.gitignore

Типы в ветках
● feature - добавление нового функционала
● fix - исправление ошибок
● refactor - рефакторинг кода без исправления ошибок или добавления новых функций
● perf - изменения направленные на улучшение производительности
● style - правки по код-стайлу
● test - добавление и изменение тестов
● doc - обновление документации

Документация по git
https://git-scm.com/book/ru/v2


